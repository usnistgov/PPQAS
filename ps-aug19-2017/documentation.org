#+TITLE: Policy Study Documentation
#+AUTHOR: Matthew Jaffee

* Overview
This is an application for studying how users read and interpret
password policies. It tracks users, allowing new users to be created,
and old users to sign in.

The purpose of the application is to have users complete a
set of questions about a password policy using information in a
password policy description document. Each user is assigned several
password policies and is asked to complete the same questionnaire for
each policy.

When the questionnaire is complete, statements of a BNF grammar are
generated which formally describe the password policy.

Most aspects of the applications behavior are configurable - there is
an administrative interface which allows several parameters to be
changed, such as the number of policies assigned to each user, and email
addresses which comments are sent to. It is also possible to add and
remove admin accounts, and change their passwords.

Other administrative functionality includes viewing raw database
information and testing the policy questionnaire.


** Dependencies
The policy study is a Flask application http://flask.pocoo.org/. It makes use
of the Jinja2 templating engine http://jinja.pocoo.org/docs/ for html
templates, and MongoDB http://www.mongodb.org/ for a
datastore. Pymongo http://api.mongodb.org/python/2.7rc0/ is used for
communicating with MongoDB.

On start up, the policy study reads in an XML file (specified in
config.py) and uses xmltodict https://github.com/martinblech/xmltodict
to convert the XML to a Python dictionary for internal manipulation.

** Datastore
There are currently 4 'collections' in the database. Their formats look like the following:

*** user
#+BEGIN_SRC python
{
"isadmin": boolean,
"date_created": isoformat date,
"done_demographic_survey: boolean,
"name": string,
"hash_name": string describing hash func for username if not admin and pass if admin,
"password_hash": string,
"policies": list of policies for this user,
"demographic_survey": {"field": "value, ....},
}
#+END_SRC

*** config
#+BEGIN_SRC python
{
"policies_per_user": int,
"comments_emails": list
"policies": list [["title", "file"], ["title2", "file"]],
"policies_used": {"title": int, "title2": int },
"policy_filenames": {"AMES": "ames.pdf", "Amazon": "amazon.pdf", ...}
}
#+END_SRC

*** questionnaire
#+BEGIN_SRC python
{
"username": string,
"policy_name": string,
"date_created": isoformat date,
"state": string ["new"|"draft"|"completed"]
"questions": {
  "1": "1.A", (select one question)
  "20.1": ["20.1.A", 20.1.G"], (select multi question)
  "13.1.A.a": 22, (numerical cloze question)
  "13.1.B.c": "second(s)", (select one cloze / memo / text)
}
}
#+END_SRC

*** logs
#+BEGIN_SRC python
{u'bnf_version': u'kevinV1',
 u'policy_name': None,
 u'xmlversion': "1.2.3",
 u'app_version': "0.1.1",
 u'qaversion': u'30oct2013v1',
 u'timestamp': 1395435599.534258,
 u'type': u'http',
 u'user_agent_browser': u'chrome',
 u'user_agent_language': None,
 u'user_agent_os': u'linux',
 u'user_agent_version': u'32.0.1700.123',
 u'user_type': u'participant',
 u'user_id': u'fk3jlk2j3kflkwjefiuiouslkdfjlkasjfdlkjk32lk3j4lk3kljiouo398009vlkjs9e809234jpzj',
 u'url': 'http://localhost:5000/policies',
 u'context': { "question:q.1.1clone2", "response:q.1.1.Aclone2" }p
}
#+END_SRC


** Report Formats
Reporting scripts (described below) pull information from the database and report it in several formats.

*** CSV reports
The CSV reports take data from the 'logs' collection in the
datastore. The keys from the log document are used as the header line
in the CSV file, and the values from each log document make up each
row in the file. The one exception is the context key which itself
contains an object full of key/value pairs. This object is expanded
into the rightmost columns and each cell will contain key: value. For
BNF events, one cell will contain the key "new" followed by a list of
all the BNF statements, and the next cell will contain "old" followed
by a list of all the BNF statements just before the latest change.

Example - The "logs" object above from the datastore documentation
would become:
#+begin_src csv
xmlversion, qaversion, bnf_version, app_version, timestamp, policy_name, user_agent_os, user_agent_browser, user_agent_version, user_agent_language, user_type, type, user_id, url
1.2.3, 30oct2013v1, kevinV1, 0.1.1, 1395435599.534258, None, linux, chrome, 32.0.1700.123, None, participant, fk3jlk2j3kflkwjefiuiouslkdfjlkasjfdlkjk32lk3j4lk3kljiouo398009vlkjs9e809234jpzj,  http://localhost:5000/policies, question:q.1.1clone2, response:q.1.1.Aclone2
#+end_src

*** R files
R files generated by the =report.py= script contain the BNF
statements for a particular questionnaire, and the corresponding
questionnaire object from the data store in comments.

** Logging
There are seven different types of logs: http, comment, response, bnf,
login, signup, and logout. They all carry the same metadata fields
described under datastore and report formats, but the context fields
may differ.

- response: has "question" and "response" context fields
- bnf: has "new" and "old" which contain lists of the current set of
  bnf statements and the previous set of bnf statements respectively
- comment: has all of the fields in the comment form as context
- http, login, signup, logout: login, signup and logout are just
  special cases of http logging which has no context



** Overall instruction flow
On application start up, =runserver.py= calls =views.initialize=. The
=initialize= function drives the functions in =elements.py=, loading the XML
file, parsing it, and preparing it for use by the application. When
this is complete, =runserver.py= calls =app.run= which starts the
webserver, and then the application is listening for requests from
user's web browsers.

When a user requests a page, the request is routed to a particular
function in =views.py= based on the =@app.route= decorators that you will
see above many of the functions. Many of the functions also have an
=@login_required= or =@admin_required= decorator which ensure that a user
is logged in before displaying that page, or is an admin respectively.

Once a request is routed, the logic in the view function
executes. Most functions end with something like =return
render_template('page.html', extradata=extradata)= This finds the
=page.html= template file (under the =templates/= subdirectory) and
potentially passes some extra data to it which jinja will use to fill
out values in the template and return an actual html page to the
user. Aside from templates, flask will also serve files from the
=static/= subdirectory, which consists of CSS, Javascript, and the PDFs
of password policies.

*** questionnaire
The most complex view/template is the policy questionnaire. Because
of it's highly dynamic and configurable nature, the questionnaire
page is set up as a single view and template which is flexible enough
to display any "page" of the questionnaire.

=elements.py= pre-processes the XML file to get it into a format which
is easily usable by the =questionnaire_page= template. The template
consists of a series of Jinja macros which call eachother to render
all the main parts of the page.


** Notable Behaviors
The application as a whole is dependent upon javascript and pop-ups
being enabled in the user's browser. There are checks for these on
most pages. The javascript check works using a noscript tag to warn
the user if javascript is disabled. The popup check works by trying to
create a popup and then showing a warning if the creation failed. If
the creation is successful, the popup is immediately closed, although
a user might see it flicker onto their screen briefly.

*** Demographics and General Comments
The demographic survey and general comments pages have sections in the
input file which allow their questions to be flexibly defined, just as
in the questionnaire. There are however, a few differences:
1. They do not have an index, because they are single page
   questionnaires. The questions defined in their respective sections
   will be rendered in the order they are written in the input file.
2. Additionally, cloning is not supported in the demographics survey,
   or on the general comments page.
3. Using "insert" in questions on the general comments page is also
   not supported since there might not be a user logged in to save
   inserted answers as.

*** Questionnaire
1. A given question should only be cloned from one location.
2. When an answer to a question which generates clones is changed such
   that the new answer does not generate a clone that the old answer
   did, a warning is popped up prompting the user to confirm the
   action. If the user confirms the action, the generated clones will
   be removed, along with any clones which depended on their answers,
   and so on down the chain of dependency.
3. For any option which triggers a question to be displayed due to a
   =display_when= attribute, any cloned question which contains that
   option will also cause the question to be displayed.

*** Input file
1. Tags which are present but have no text will cause an empty string
   to be used as the value unless otherwise noted. (i.e. "leave blank
   to disable")
2. If a =BNF_mapping= tag has a "when" attribute, all options in the
   comma separated list must be selected for the statement to be
   generated. As a debugging tool, the statement will be generated
   when any of the options are selected, but if not all are selected,
   the string "INCOMPLETE BNF (missing options)" will be prepended to
   the BNF statement.
3. If a particular tag is left completely empty, it is by default
   given a value of =None=. This is not very convenient for this
   application, and so there is a way built in to automatically
   convert all =None= values in the input file to something else. In
   =config.py=, you will find the parameter CONVERT_NONE_TO, which you
   can set equal to an empty string (the default), or any other string
   you like for debugging purposes.



* Scripts
The application comes with a set of scripts for generating reports,
backing up the data store - switching to a clean datastore, etc.

Call scripts by executing =python policy_study/script_name.py=
followed by whatever commands and options are necessary. Almost all
modes of all scripts may take an optional argument of
--dbname=<dbname>, the name of the mongo database to operate on. The
default database name is "policydb".

** report.py
The report script has multiple modes.

*** BNF
=bnf [options] <outputdir>=

Writes a file per questionnaire to the output directory which contains the bnf statements for that questionnaire.
*** Report
=[options] <outfile>=

Writes a single file which contains all collected log data in CSV format

*** Report per
=[options] <field> <outputdir>=

Writes one file per unique value of =field= name to the outputdir
containing the logs which have that field equal to that value. Writes
logs which do not have that field to a file named =None=.
*** Extra
=[options] extra <outfile>=

Writes a csv file with the following header
#+begin_src txt
"object_id", "username", "policy_name", "state", "date_completed", "BNF statement"
#+end_src
one line per BNF statement in the data store.

** =store_admin.py=
The store administration script has 2 modes.
*** cp
=cp [options] <target_name>=

Copy the given dbname, or the default database to a new name - potentially to save for later reports.

*** rm
=rm <db_to_remove>=

Drop the named database. Dropping policydb will reset the application to a clean slate.

** mongodump
Mongodump is a script that comes with MongoDB. You should be able to
run it simply by typing 'mongodump'. It will write the contents of
whatever database it is given to disk. Options for controlling it are
available by executing =mongodump --help=.

* Tests

Tests can be found in the =test_*.py= files. Tests use the py.test
framework and can be run by changing to the =policy_study= directory
and running py.test like so:
#+BEGIN_SRC bash
$ cd policy_study
$ py.test
================================================ test session starts =================================================
platform linux2 -- Python 2.7.7 -- py-1.4.20 -- pytest-2.5.2
collected 32 items

test_bnf.py ....
test_clones.py .....
test_elements.py ..........
test_tree.py ..
test_utils.py .......
test_validation.py ....

============================================= 32 passed in 0.99 seconds =============================================
#+END_SRC
Tests for a given module are in =test_MODULENAME.py=.
* File Layout
** setup.py
Project file for python setuptools. Running =python setup.py install=
will download all necessary dependencies to run the application.

** runserver.py
Running =python runserver.py= starts a lightweight development server for testing the application.

** policy\_study/
The policy\_study directory contains application code and tests.

*** *.py files
All of the =.py= files that don't start with test_ are python
application code.

*** test\_*.py files
Files containing tests which are named after the file they are
testing. i.e. =test_utils.py= contains tests for functions in
=utils.py=.

*** templates
The templates directory contains =.html= files which are actually
Jinja2 templates. Each of these files corresponds to a page in the
policy except for =common.html= which contains common elements which
most of the other pages inherit, and =macros.html= which contains
Jinja2 macros that the other template files can use.

*** static
The static directory contains files which the webserver will need to
access to serve directly. This includes stylesheets (CSS),
Javascript, images/icons, and fonts. All CSS written for the
application is in =style.css=. The majority of the javascript is in
=questionnaire.js=, although there are a few page specific pieces in
=demosurvey_page.js=, =general_comments_page.js=, and
=questionnaire_page.js=. All other =.js= and =.css= files are
libraries which were pulled in from outside sources.

** documented-input.xml
This is an annotated version of the input xml file which explains what each element is used for.

** resources
The resources directory contains a number of non-code files used by
the application.

*** policies.txt
A text file of the format:
#+BEGIN_SRC txt
Policy Name|filename.pdf
Policy Name2|filename2.pdf
#+END_SRC
Where =Policy Name= is the title which will be given to the policy in
the application, and filename.pdf is the name of the file to take
from the =policies= directory (also under =resources=).

Each user has a list of the titles associated with them. A persistent
mapping from title to filename is stored in the "config" collection in
the database. When you change a title, a new entry gets added to the
mapping with the new title and the old filename - The old title will
continue working as it did before. If you change the filename
associated with a particular title, then any user who has that title
will now be served the new filename.

To be more succint:
Changing a title adds to the title:filename mapping, whereas changing
a filename changes the mapping.

*** polices
Contains policy pdfs, which are specified in policies.txt.


** Input XML file
The input xml file (which, at the time of this writing, is set to
=pp_test.xml= in =policy_study/config.py=. See =documented-input.xml=
for more information.
* Moving to production
** Installing and configuring production application
Adapted from:
http://vladikk.com/2013/09/12/serving-flask-with-nginx-on-ubuntu/


Create production directory, and chown to yourself for setup convenience
#+begin_src bash
sudo mkdir /var/www/policy_study
sudo chown -R mij:mij policy_study
#+end_src

Create the python virtualenv and point it to a python 2.7.8 executable
you'll have to make sure this python executable is accessible by
www-data or whatever user you end up using for uwsgi.
#+begin_src bash
cd /var/www/policy_study
virtualenv -p /home/mij/usr/bin/python2.7 venv
source venv/bin/activate
#+end_src

Clone the repository
#+begin_src bash
git clone mij@localhost:/home/mij/opt/git/policy_study.git .
#+end_src


Install dependencies
#+begin_src bash
python setup.py install
#+end_src

Install MongoDB - consult documentation for your operating
system. Ubuntu docs are found here:
http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/.
For Debian based systems, something like the following will generally
work.
#+begin_src bash
sudo apt-get -y install mongodb-org
#+end_src
If Mongo does not start automatically, you may have to start it before
you'll be able to run the application. Consult the Mongo documentation
for the proper way to start it on your system.


Edit =policy_study/config.py= to point to the correct resource files and
database.  I added the =BASE_DIR= line and modified the other 4 - leave
the rest of the file the same
#+begin_src python
BASE_DIR="/var/www/policy_study/"
DBNAME = "production_policydb"
POLICY_DIR = BASE_DIR + "resources/policies/"
POLICY_FILE = BASE_DIR + "resources/policies.txt"
INPUT_FILE = BASE_DIR + "resources/pp_test.xml"
#+end_src

Install uwsgi
#+begin_src bash
sudo apt-get install build-essential python-dev
pip install uwsgi
#+end_src

Install nginx
#+BEGIN_SRC bash
sudo add-apt-repository ppa:nginx/stable
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install nginx
sudo /etc/init.d/nginx start
#+END_SRC

Configure nginx
#+begin_src bash
sudo rm /etc/nginx/sites-enabled/default
#+end_src

Create nginx conf file =/etc/nginx/conf.d/policy_study_nginx.conf=
#+begin_src conf
    server {
        listen      80;
        server_name localhost;
        charset     utf-8;
        client_max_body_size 75M;

        location / { try_files $uri @policy_study; }
        location @policy_study {
            include uwsgi_params;
            uwsgi_pass unix:/var/www/policy_study/policy_study_uwsgi.sock;
        }
    }
#+end_src


Create uwsgi ini file =/var/www/policy_study_uwsgi.ini=
#+begin_src conf
    [uwsgi]
    #application's base folder
    base = /var/www/policy_study

    #python module to import
    app = policy_study
    module = %(app)

    home = %(base)/venv
    pythonpath = %(base)

    #socket file's location
    socket = /var/www/policy_study/%n.sock

    #permissions for the socket file
    chmod-socket    = 644

    #the variable that holds a flask application inside the module imported at line #6
    callable = app

    #location of log files
    logto = /var/log/uwsgi/%n.log
#+end_src


Create and chown uwsgi log directory.
#+begin_src bash
sudo mkdir -p /var/log/uwsgi
sudo chown -R mij:mij /var/log/uwsgi
#+end_src


Configure uwsgi to run as a background processes using uwsgi emperor.
Edit uwsgi emperor conf =/etc/init/uwsgi.conf=
#+begin_src conf
    description "uWSGI"
    start on runlevel [2345]
    stop on runlevel [06]
    respawn
    env UWSGI=/var/www/policy_study/venv/bin/uwsgi
    env LOGTO=/var/log/uwsgi/emperor.log
    exec $UWSGI --master --emperor /etc/uwsgi/vassals --die-on-term --uid www-data --gid www-data --logto $LOGTO
#+end_src

Finish configuring emperor
#+begin_src bash
sudo mkdir /etc/uwsgi && sudo mkdir /etc/uwsgi/vassals
sudo ln -s /var/www/policy_study/policy_study_uwsgi.ini /etc/uwsgi/vassals
sudo chown -R www-data:www-data /var/www/policy_study
#+end_src

Start it up
#+begin_src bash
sudo start uwsgi
#+end_src

** Updating Production Code Base
*** Pull down the code
#+begin_src bash
cd /var/www/policy_study
sudo git pull
#+end_src

If you encounter problems at this step (merge conflicts, "you must
commit your changes", that sort of thing), it is probably because of
the changes made to config.py (see the install instructions). You can
do =git status= and =git diff= to see what your changes are, then:
#+begin_src bash
git stash
git pull
# and optionally
git stash apply
# or you can just edit config.py and add your changes back in
#+end_src


*** It may be necessary to restart uwsgi - depending on the code change
#+begin_src bash
sudo stop uwsgi
sudo start uwsgi
#+end_src
* Running Multiple Instances for Testing purposes
You can run multiple instance of the policy study (with different input files, and data stores) simultaneously.
** Instructions
*** Check out a fresh copy of the codebase.

*** Edit runserver.py
Replace the line
#+begin_src python
app.run(debug=True, host='0.0.0.0')
#+end_src
with a line like:
#+begin_src python
app.run(debug=True, host='0.0.0.0', port=5001)
#+end_src

You can replace 5001 with anything from 1000 to 65536, as long as
it doesn't conflict with an already running service. If the server
fails to start, try changing the number.

*** Edit =policy_study/config.py=
Replace the line
#+begin_src python
DBNAME = "policydb"
#+end_src
with a line like:
#+begin_src python
DBNAME = "mickyTestingSection2"
#+end_src

Once again, with each further instance, you just have to keep changing to a different (unique) name.

*** Start it up as usual

Just remember to navigate to the appropriate instance - if you were
going to http://policyserver.nist.gov:5000 before, now you need to go
to http://policyserver.nist.gov:5001
